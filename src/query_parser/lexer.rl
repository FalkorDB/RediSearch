#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <math.h>

#include "parse.h"
#include "parser.h"
#include "../query_node.h"
#include "../stopwords.h"

/* forward declarations of stuff generated by lemon */

#define RSQuery_Parse RSQueryParser_
#define RSQuery_ParseAlloc RSQueryParser_Alloc
#define RSQuery_ParseFree RSQueryParser_Free

void RSQuery_Parse(void *yyp, int yymajor, QueryToken yyminor, QueryParse *ctx);
void *RSQuery_ParseAlloc(void *(*mallocProc)(size_t));
void RSQuery_ParseFree(void *p, void (*freeProc)(void *));

%%{

machine query;

inf = ['+\-']? 'inf' $ 3;
number = '-'? digit+('.' digit+)? (('E'|'e') '-'? digit+)? $ 2;

quote = '"';
or = '|';
lp = '(';
rp = ')';
lb = '{';
rb = '}';
colon = ':';
semicolon = ';';
arrow = '=>';
minus = '-';
tilde = '~';
star = '*';
percent = '%';
rsqb = ']';
lsqb = '[';
escape = '\\';
escaped_character = escape (punct | space | escape);
term = (((any - (punct | cntrl | space | escape)) | escaped_character) | '_')+  $ 0 ;
prefix = (term.star | number.star) $1;
mod = '@'.term $ 1;
attr = '$'.term $ 1;

main := |*

  number => {
    tok.s = ts;
    tok.len = te-ts;
    char *ne = (char*)te;
    tok.numval = strtod(tok.s, &ne);
    tok.pos = ts-raw;
    Parse(NUMBER, tok);
    if (!IsOk()) {
      fbreak;
    }
  };
  mod => {
    tok.pos = ts-raw;
    tok.len = te - (ts + 1);
    tok.s = ts+1;
    Parse(MODIFIER, tok);
    if (!IsOk()) {
      fbreak;
    }
  };
  attr => {
    tok.pos = ts-raw;
    tok.len = te - (ts + 1);
    tok.s = ts+1;
    Parse(ATTRIBUTE, tok);
    if (!IsOk()) {
      fbreak;
    }
  };
  arrow => {
    tok.pos = ts-raw;
    tok.len = te - ts;
    tok.s = ts+1;
    Parse(ARROW, tok);
    if (!IsOk()) {
      fbreak;
    }
  };
  inf => {
    tok.pos = ts-raw;
    tok.s = ts;
    tok.len = te-ts;
    tok.numval = *ts == '-' ? -INFINITY : INFINITY;
    Parse(NUMBER, tok);
    if (!IsOk()) {
      fbreak;
    }
  };
  quote => {
    tok.pos = ts-raw;
    Parse(QUOTE, tok);
    if (!IsOk()) {
      fbreak;
    }
  };
  or => {
    tok.pos = ts-raw;
    Parse(OR, tok);
    if (!IsOk()) {
      fbreak;
    }
  };
  lp => {
    tok.pos = ts-raw;
    Parse(LP, tok);
    if (!IsOk()) {
      fbreak;
    }
  };
  rp => {
    tok.pos = ts-raw;
    Parse(RP, tok);
    if (!IsOk()) {
      fbreak;
    }
  };
  lb => {
    tok.pos = ts-raw;
    Parse(LB, tok);
    if (!IsOk()) {
      fbreak;
    }
  };
  rb => {
    tok.pos = ts-raw;
    Parse(RB, tok);
    if (!IsOk()) {
      fbreak;
    }
  };
  colon => {
    tok.pos = ts-raw;
    Parse(COLON, tok);
    if (!IsOk()) {
      fbreak;
    }
  };
  semicolon => {
    tok.pos = ts-raw;
    Parse(SEMICOLON, tok);
    if (!IsOk()) {
      fbreak;
    }
  };
  minus =>  {
    tok.pos = ts-raw;
    Parse(MINUS, tok);
    if (!IsOk()) {
      fbreak;
    }
  };
  tilde => {
    tok.pos = ts-raw;
    Parse(TILDE, tok);
    if (!IsOk()) {
      fbreak;
    }
  };
  star => {
    tok.pos = ts-raw;
    Parse(STAR, tok);
    if (!IsOk()) {
      fbreak;
    }
  };
  percent => {
    tok.pos = ts-raw;
    Parse(PERCENT, tok);
    if (!IsOk()) {
      fbreak;
    }
  };
  lsqb => {
    tok.pos = ts-raw;
    Parse(LSQB, tok);
    if (!IsOk()) {
      fbreak;
    }
  };
  rsqb => {
    tok.pos = ts-raw;
    Parse(RSQB, tok);
    if (!IsOk()) {
      fbreak;
    }
  };
  space;
  punct;
  cntrl;

  term => {
    tok.len = te-ts;
    tok.s = ts;
    tok.numval = 0;
    tok.pos = ts-raw;
    if (!opts->stopwords->Contains(tok.s, tok.len)) {
      Parse(TERM, tok);
    } else {
      Parse(STOPWORD, tok);
    }
    if (!IsOk()) {
      fbreak;
    }
  };
  prefix => {
    tok.len = te-ts - 1;
    tok.s = ts;
    tok.numval = 0;
    tok.pos = ts-raw;

    Parse(PREFIX, tok);

    if (!IsOk()) {
      fbreak;
    }
  };


*|;
}%%

%% write data;

QueryNode *QueryParse::ParseRaw() {
  parser = RSQuery_ParseAlloc(rm_malloc);

  int cs, act;
  const char* ts = raw;
  const char* te = raw + len;
  %% write init;
  QueryToken tok;

  const char* p = raw;
  const char* pe = raw + len;
  const char* eof = pe;

  %% write exec;

  if (IsOk()) {
    Parse(0, tok);
  }
  RSQuery_ParseFree(parser, rm_free);
  if (!IsOk() && root) {
    delete root;
    root = NULL;
  }
  return root;
}

void QueryParse::Parse(int yymajor, QueryToken yyminor) {
  RSQuery_Parse(parser, yymajor, yyminor, this);
}
